== 5章: RDKitで構造情報を取り扱う
:imagesdir: images

image:jupyter.png[link="https://github.com/Mishima-syk/py4chemoinformatics/blob/master/notebooks/ch05_rdkit.ipynb"]

この章ではRDKitを使って分子の読み込みの基本を覚えます。

=== SMILESとは

Simplified molecular input line entry system(SMILES)とは化学構造を文字列で表現するための表記方法です。
詳しくはlink:http://www.daylight.com/meetings/summerschool98/course/dave/smiles-intro.html#TOC[SMILES Tutorial]で説明されていますが、例えばc1ccccc1は6つの芳香族炭素が最初と最後をつないでループになっている構造、つまりベンゼンを表現していることになります。

=== 構造を描画してみよう

SMILESで分子を表現することがわかったので、SMILESを読み込んで分子を描画させてみましょう。まずはRDKitのライブラリからChemクラスを読み込みます。二行目はJupyter Notebook上で構造を描画するための設定です。

[source, python]
----
from rdkit import Chem
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw
----

RDKitにはSMILES文字列を読み込むためにMolFromSmilesというメソッドが用意されていますので、これを使い分子を読み込みます。

[source, python]
----
mol = Chem.MolFromSmiles("c1ccccc1")
----

続いて構造を描画しますが、単純にmolを評価するだけで構造が表示されます。

[source, python]
----
mol
----

図のように構造が表示されているはずです。

image::ch05/ch05_01.png[Depict benzene]

上のように原子を線でつなぎ構造を表現する方法（構造式）と、SMILES表記はどちらも同じものを表現しています。構造式は人が見てわかりやすいですが、SMILESはASCII文字列で表現されるのでより少ないデータ量で表現できるというメリットがあります。

NOTE: 文字列で表現できるということは、文字列生成アルゴリズムを応用することで新規な化学構造を生成することも可能ということです。この内容に関しては12章で詳しく説明します。


=== 複数の化合物を一度に取り扱うには？

複数の化合物を一つのファイルに格納する方法にはいくつかありますが、sdfというファイル形式を利用するのが一般的です。

.sdfフォーマットとは？
****
MDL社で開発された分子表現のためのフォーマットにMOL形式というものがあります。このMOL形式を拡張したものがSDF形式です。具体的にはMOL形式で表現されたものを"$$$$"という行で区切ることにより、複数の分子を取り扱えるようにしてあります。

MOL形式は分子の三次元座標を格納することができ二次元だけでなく立体構造を表現できる点はSMILESとの大きな違いです。
****

==== sdfファイルをChEMBLからダウンロードする

4章を参考にlink:https://www.ebi.ac.uk/chembl/beta/[ChEMBL]のトポイソメラーゼII阻害試験(CHEMBL669726)の構造データをsdfファイル形式でダウンロードします。

NOTE::
****
具体的な手順はリンクのページを開いて、検索フォームにCHEMBL669726を入力すると検索結果が表示されるので、Compoundsタブをクリックします。その後、全選択してSDFでダウンロードするとgzip圧縮されたsdfがダウンロードされるので、gunzipコマンドまたは適当な解凍ソフトで解凍してください。それをch05_compounds.sdfという名前で保存します。
****

==== RDKitでsdfを取り扱う

RDKitでsdfファイルを読み込むにはSDMolSupplierというメソッドを利用します。複数の化合物を取り扱うことになるのでmolではなくmolsという変数に格納していることに注意してください。どういう変数を使うかの決まりはありませんが、見てわかりやすい変数名をつけることで余計なミスを減らすことは心がけるとよいでしょう。

[source, python]
----
mols = Chem.SDMolSupplier("ch05_compounds.sdf")
----

何件の分子が読み込まれたのか確認します。数を数えるにはlenを使います。

[source, python]
----
len(mols)
----

34件でした。

==== 分子の構造を描画する

forループを使って、ひとつずつ分子を描画してもいいですが、RDKitには複数の分子を一度に並べて描画するメソッドが用意されているので、今回はそちらのMolsToGridImageメソッドを使います。なお一行に並べる分子の数を変更するにはmolsPerRowオプションで指定します

[source, python]
----
Draw.MolsToGridImage(mols)
----

image::ch05/ch05_04.png[MolsToGridImage]

===== (おまけ)
参考までにループを回すやりかたも載せておきます。

[source, python]
----
from IPython.core.display import display
for mol in mols:
    display(mol)
----

=== ヘテロシャッフリングをしてみる

image:jupyter.png[link="https://github.com/Mishima-syk/py4chemoinformatics/blob/master/notebooks/ch05_hetero_shuffle.ipynb"]

化合物の物性を変換するアプローチの一つとしてヘテロシャッフリングがあります。これは置換基の位置関係は維持したまま、芳香環を形成する炭素、窒素、硫黄、酸素などの原子種を入れ替えて新しい分子を生み出す手法です。

ヘテロシャッフリングをすることで活性を維持しつつ、脂溶性などのプロパティを変化させてADMETの課題を解決する、または活性そのものを改善する、特許対策の効果をなど期待します。非常に有名な例としてはPfizer社のSildenafilとGSK社のVardinafilが挙げられます。
実際の現場では単にシャッフルしたものを何でも作ることはなく、Docking Studyなどをして好ましい相互作用を持つ分子のみを選んだりします。その前段階としていろんな分子を生成することは一つのアプローチとしてあっても良いでしょう。

RDKITで再帰的にヘテロシャッフルした分子を生成するコードを書いてみました。
下記が実際のコード部分です。芳香環を形成する原子のインデックスを取得し、総当たりでC, N, S, Oに変えていきます。変えたものに関してSanitizeMolのチェックかけてパスしたもののみを返します。
recursive_replaceという関数が再帰的に原子を入れ替えます。Thresholdの値がオプションで設定できます。これは入力分子内の芳香環を形成する原子に対する芳香環を形成する窒素原子の数の割合です。これを設定しているのは、芳香環嬢の原子が全て炭素以外の原子になってしまうのは違和感があるからです。

[source, python]
----
def replace_atom(mol):
    res = []
    aro_idxs = [atom.GetIdx() for atom in mol.GetAromaticAtoms() if atom.GetDegree() < 3]
    for atm_num in [6, 7, 8, 16]:
        for idx in aro_idxs:
            cp_mol = copy.deepcopy(mol)
            cp_mol.GetAtomWithIdx(idx).SetAtomicNum(atm_num)
            p = Chem.MolFromSmarts("nnn")
            if cp_mol.HasSubstructMatch(p) != True:
                try:
                    smi = Chem.MolToSmiles(cp_mol)
                    smi.replace("[sH]", "s")
                    cp_mol = Chem.MolFromSmiles(smi)
                    Chem.SanitizeMol(cp_mol)
                    res.append(cp_mol)
                except:
                    pass
    return res
 
def recursive_replace(mols, check=set([]), thres=0.4):
    before_n = len(check)
    print(before_n)
    for mol in mols:
        replaced_mols = replace_atom(mol)
        for mol_conv in replaced_mols:
            aro_n = Fragments.fr_Ar_N(mol)
            aro_a = len(mol.GetAromaticAtoms())
            ratio = float(aro_n) / float(aro_a)
            if ratio < thres:
                smi = Chem.MolToSmiles(mol_conv)
                check.add(smi)
    after_n = len(check)
    print(before_n, after_n)
    if before_n < after_n:
        mols = [Chem.MolFromSmiles(mol) for mol in check]
        recursive_replace(mols, check=check)
    return [Chem.MolFromSmiles(smi) for smi in check]
----

実際に使ってみます。

[source, python]
----
# Gefitinib
mol1 = Chem.MolFromSmiles('COC1=C(C=C2C(=C1)N=CN=C2NC3=CC(=C(C=C3)F)Cl)OCCCN4CCOCC4')
#  Oxaprozin
mol2 = Chem.MolFromSmiles('C1=CC=C(C=C1)C2=C(OC(=N2)CCC(=O)O)C3=CC=CC=C3')
Draw.MolsToGridImage([mol1, mol2])
----

元の分子

image::ch05/ch05_05.png[query]

[source, python]
----
res = recursive_replace([mol1])
Draw.MolsToGridImage(res, molsPerRow=5)
----

変換後１

image::ch05/ch05_06.png[res1]

[source, python]
----
res = recursive_replace([mol2])
Draw.MolsToGridImage(res, molsPerRow=5)
----

変換後２

image::ch05/ch05_07.png[res2]

どうでしょうか。二つの分子の例を示しました。一つ目は66の芳香環であり、それを形成できる原子は炭素と、窒素のみの場合です。
二つ目は５員環で炭素、窒素、硫黄、酸素が原子の候補として入る場合の例です。
いずれのケースでも上記のコードでヘテロ原子がシャッフルされたものが生成されています

.ヘテロシャッフリングについてもう少し詳しく
****
link:https://pubs.acs.org/doi/10.1021/jm3001289[J. Med. Chem. 2012,  55, 11, 5151-5164]ではPIM-1キナーゼ阻害剤におけるNシャッフリングの効果をFragment Molecular Orbital法という量子化学的なアプローチを使って検証しています。さらにlink:https://pubs.acs.org/doi/10.1021/acs.jcim.8b00563[J. Chem. Inf. Model. 2019,  59, 1, 149-158]ではAsp–Arg塩橋とヘテロ環のスタッキングのメカニズムを量子化学計算により探っており、置換デザインの指標になりそうです。

また、バイオアベイラビリティ改善のためにヘテロシャッフリングを行った例としてはlink:https://dx.doi.org/10.1021/jm101027s[J. Med. Chem. 2011,  54, 8, 3076-3080]があります。
****

<<<
